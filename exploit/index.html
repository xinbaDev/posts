<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>How to build a website full of vulnerabilities &#183; Alex's Blog</title><link rel=stylesheet href=/posts/css/style.css><link rel=stylesheet href=/posts/css/fonts.css><link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=32x32 href=/posts/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/posts/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/posts/images/apple-touch-icon.png><link href rel=alternate type=application/rss+xml title="Alex's Blog"></head><body><nav class=nav><div class=nav-container><a href=/posts/><h2 class=nav-title>Alex's Blog</h2></a><ul></ul></div></nav><main><div class=post><div class=post-info><span>Written by</span>
Alex<br><span>on&nbsp;</span><time datetime="2019-09-19 19:39:11 +1100 +1100">September 19, 2019</time></div><h1 class=post-title>How to build a website full of vulnerabilities</h1><div class=post-line></div><p>Recently, while studying OWASP TOP10, I came across a open-source web app called <a href=https://github.com/bkimminich/juice-shop>juiceshop</a>, which contains various types of vulnerabilities. After taking a closer look, I found out that this small web app has 88 vulnerabilities ranging from A1 to A9.</p><h2 id=a1--injection>A1 : Injection</h2><p>When users interact with websites, there are several instances where they&rsquo;re required to provide certain parameters. These parameters are then transmitted to other servers, including databases and third-party applications, by the web server for further processing. However, if these user-defined parameters are not validated and filtered before being transmitted to other servers, it can lead to injection attacks.</p><p>Example 1:</p><p>Let&rsquo;s first take a look at the example of &ldquo;Login Admin&rdquo;.</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports = function login () {

    ...
    
  return (req, res, next) =&gt; {
    verifyPreLoginChallenges(req)
    models.sequelize.query('SELECT * FROM Users WHERE email = \'' + 
    (req.body.email || '') + '\' AND password = \'' + 
    insecurity.hash(req.body.password || '') + '\' 
    AND deletedAt IS NULL', { model: models.User, plain: true })
      .then((authenticatedUser) =&gt; {
        let user = utils.queryResultToJson(authenticatedUser)
        
        ...
        
        afterLogin(user, res, next)
  }
</code></pre><p>This is a typical SQL injection vulnerability code, where the &ldquo;email&rdquo; parameter is not validated and is directly used to construct a raw SQL statement. A user can set the email parameter to ' or 1=1 &ndash; to make the entire SQL statement become SELECT * FROM Users WHERE email ='' or 1=1 &ndash; &mldr;., which can cause the database to execute incorrect instructions and return all user information.</p><p>Example 2:</p><p>NoSQL Injection.</p><pre><code class="language-javascript=" data-lang="javascript=">
module.exports = function trackOrder () {
  return (req, res) =&gt; {
    req.params.id = utils.trunc(decodeURIComponent(req.params.id), 40)
    db.orders.find({ $where: &quot;this.orderId === '&quot; + req.params.id + &quot;'&quot; }).then(order =&gt; {
      const result = utils.queryResultToJson(order)
      if (result.data[0] === undefined) {
        result.data[0] = { orderId: req.params.id }
      }
      res.json(result)
    }, () =&gt; {
      res.status(400).json({ error: 'Wrong Param' })
    })
  }
}
</code></pre><p>This is a typical vulnerability of NoSQL injection. The &ldquo;orderid&rdquo; has not been validated and filtered, which results in the NoSQL statement becoming &ldquo;db.orders.find({ $where: this.orderId === '' || true || '' })&rdquo; when the user inputs &ldquo;id=' || true || &lsquo;&rdquo;, and all orders are returned as a result.</p><p>Case 3</p><p>In addition to database injection, there are also injections that directly call the server&rsquo;s system programs, leading to remote code execution. For example, using a template engine to execute remote code. In Juiceshop, the username is generated using the Pug template engine, and using &ldquo;#{1+1}&rdquo; as the username will display &ldquo;2&rdquo; as the username on the webpage.</p><h2 id=a2-broken-authentication-and-session-management>A2: Broken Authentication and Session Management</h2><p>Case 1</p><p>Login CISO</p><p>Oauth2 is a very common industry standard for user authentication, widely used for third-party logins. In Juiceshop, there are significant issues with the implementation of oauth2 login.</p><p>Front-end code:</p><pre><code class="language-javascript=" data-lang="javascript=">
ngOnInit () {
    this.userService.oauthLogin(this.parseRedirectUrlParams()['access_token']).subscribe((profile: any) =&gt; {
        let password = btoa(profile.email.split('').reverse().join(''))
        this.userService.save({ email: profile.email, password: password, passwordRepeat: password }).subscribe(() =&gt; {
        this.login(profile)
        }, () =&gt; this.login(profile))
    }, (error) =&gt; {
        this.invalidateSession(error)
        this.router.navigate(['/login'])
    })
}

  
login (profile: any) {
    this.userService.login({
        email: profile.email, password: 
        btoa(profile.email.split('').reverse().join('')), oauth: true 
    }).subscribe((authentication) =&gt; {
      this.cookieService.put('token', authentication.token)
      localStorage.setItem('token', authentication.token)
      sessionStorage.setItem('bid', authentication.bid)
      this.userService.isLoggedIn.next(true)
      this.router.navigate(['/'])
    }, (error) =&gt; {
      this.invalidateSession(error)
      this.router.navigate(['/login'])
    })
}
</code></pre><p>backend codeï¼š</p><pre><code class="language-javascript=" data-lang="javascript=">
exports.userEmailFrom = ({ headers }) =&gt; {
  return headers ? headers['x-user-email'] : undefined
}

module.exports = function login () {

    ...

    const rememberedEmail = insecurity.userEmailFrom(req)
    // When selecting the option to log in by remembering the email, 
    // as long as the oauth parameter and the x-user-email header are added, 
    // the login can be achieved.&quot;
    if (rememberedEmail &amp;&amp; req.body.oauth) {
      models.User.findOne({ where: { email: rememberedEmail } }).then(rememberedUser =&gt; {
        user = utils.queryResultToJson(rememberedUser)
        afterLogin(user, res, next)
      })
    }
    
    ...
}
</code></pre><p>Through this OAuth2 login vulnerability, hackers can log in just by knowing the user&rsquo;s email.</p><h2 id=a3-sensitive-information-disclosure>A3: Sensitive Information Disclosure</h2><p>Case: FTP Path Disclosure</p><p>In about.component.html,</p><pre><code class=language-htmlmixed data-lang=htmlmixed>&lt;a href=&quot;/ftp/legal.md&quot; aria-label=&quot;Link to the Terms of Use&quot; translate&gt;LINK_TERMS_OF_USE&lt;/a&gt;
</code></pre><p>We can see that the server has an FTP folder, and by accessing this address, it returns:</p><p><img src=https://i.imgur.com/mH4rDrm.png alt></p><p>There are a series of files inside, including some server configuration files and a backup of coupons. When trying to download one of the files, the server returns an error saying that only files ending with .md and .pdf can be downloaded. However, this server code intentionally leaves a vulnerability.</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports = function servePublicFiles () {
  return ({ params, query }, res, next) =&gt; {
    const file = params.file

    if (!file.includes('/')) {
      verify(file, res, next)
    } else {
      res.status(403)
      next(new Error('File names cannot contain forward slashes!'))
    }
  }

  function verify (file, res, next) {
    // First, verify if the file has an md or pdf extension.
    if (file &amp;&amp; (endsWithWhitelistedFileType(file) || 
        (file === 'incident-support.kdbx'))) {
      // However, the file name is processed later, causing the file name to be 
      // different from the one passed in.
      file = insecurity.cutOffPoisonNullByte(file)
      res.sendFile(path.resolve(__dirname, '../ftp/', file))
    } else {
      res.status(403)
      next(new Error('Only .md and .pdf files are allowed!'))
    }
  }


  function endsWithWhitelistedFileType (param) {
    return utils.endsWith(param, '.md') || utils.endsWith(param, '.pdf')
  }
}

exports.cutOffPoisonNullByte = str =&gt; {
  const nullByte = '%00'
  if (utils.contains(str, nullByte)) {
    return str.substring(0, str.indexOf(nullByte))
  }
  return str
}
</code></pre><h2 id=a4-xml-external-entity-vulnerability-xxe>A4: XML External Entity Vulnerability (XXE)</h2><p>Example: Remote Reading of Server Files</p><p>In Juiceshop, users can trigger an XXE vulnerability by uploading an XML file. The vulnerable code is as follows:</p><pre><code class="language-javascript=" data-lang="javascript=">function handleXmlUpload ({ file }, res, next) {
  if (utils.endsWith(file.originalname.toLowerCase(), '.xml')) {
    if (file.buffer &amp;&amp; !utils.disableOnContainerEnv()) { 
    // XXE attacks in Docker/Heroku containers regularly cause &quot;segfault&quot; crashes
      const data = file.buffer.toString()
      try {
        const sandbox = { libxml, data }
        vm.createContext(sandbox)
        
        // No validation is performed on user-uploaded files (input).
        const xmlDoc = vm.runInContext('libxml.parseXml(data, { noblanks: true, noent: true, nocdata: true })', sandbox, { timeout: 2000 })
        const xmlString = xmlDoc.toString(false)
        res.status(410)
        next(new Error('B2B customer complaints via file upload have been deprecated for security reasons: ' + utils.trunc(xmlString, 200) + ' (' + file.originalname + ')'))
      } catch (err) {
        if (utils.contains(err.message, 'Script execution timed out')) {
          if (utils.notSolved(challenges.xxeDosChallenge)) {
            utils.solve(challenges.xxeDosChallenge)
          }
          res.status(503)
          next(new Error('Sorry, we are temporarily not available! Please try again later.'))
        } else {
          res.status(410)
          next(new Error('B2B customer complaints via file upload have been deprecated for security reasons: ' + err.message + ' (' + file.originalname + ')'))
        }
      }
    } else {
      res.status(410)
      next(new Error('B2B customer complaints via file upload have been deprecated for security reasons (' + file.originalname + ')'))
    }
  }
  res.status(204).end()
}
</code></pre><p>&ldquo;Using a simple external entity reference can trigger this remote file reading vulnerability.</p><pre><code class="language-xml=" data-lang="xml=">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
        &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;

&lt;test&gt;
    &lt;foo&gt;&amp;xxe;&lt;/foo&gt;
&lt;/test&gt;		
</code></pre><h2 id=a5-lack-of-function-level-access-control>A5: Lack of Function-Level Access Control</h2><p>In a website, some features are specific to certain users. If these features are not properly authenticated or are authenticated with incorrect permissions, it can lead to authorization vulnerabilities.</p><p>Example 1: Accessing other people&rsquo;s shopping carts.</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports.addBasketItem = function addBasketItem () {
  return (req, res, next) =&gt; {
    var result = utils.parseJsonCustom(req.rawBody)
    var productIds = []
    var basketIds = []
    var quantities = []

    for (var i = 0; i &lt; result.length; i++) {
      if (result[i].key === 'ProductId') {
        productIds.push(result[i].value)
      } else if (result[i].key === 'BasketId') {
        basketIds.push(result[i].value)
      } else if (result[i].key === 'quantity') {
        quantities.push(result[i].value)
      }
    }

    const user = insecurity.authenticatedUsers.from(req)
    // Validate the basket ID here
    if (user &amp;&amp; basketIds[0] &amp;&amp; basketIds[0] !== 'undefined' &amp;&amp; user.bid != basketIds[0]) { // eslint-disable-line eqeqeq
      res.status(401).send('{\'error\' : \'Invalid BasketId\'}')
    } else {
      // However, the stored basket ID here may not necessarily have been validated.
      const basketItem = {
        ProductId: productIds[productIds.length - 1],
        BasketId: basketIds[basketIds.length - 1],
        quantity: quantities[quantities.length - 1]
      }

      const basketItemInstance = models.BasketItem.build(basketItem)
      basketItemInstance.save().then((basketItem) =&gt; {
        basketItem = {
          status: 'success',
          data: basketItem
        }
        res.json(basketItem)
      }).catch(error =&gt; {
        next(error)
      })
    }
  }
}

</code></pre><p>By making a POST request to api/BasketItems with a payload of {&ldquo;ProductId&rdquo;:30, &ldquo;BasketId&rdquo;:&ldquo;4&rdquo;, &ldquo;quantity&rdquo;:1, &ldquo;BasketId&rdquo;:&ldquo;3&rdquo;}, this vulnerability can be triggered, causing a product with ID 30 to be added to the shopping cart with basket ID 3.</p><h2 id=a6-configuration-error>A6: Configuration Error</h2><p>Case: The deprecated interface was not properly closed.</p><p>In HTML, only two file types, PDF and ZIP, are allowed to be uploaded:</p><pre><code class="language-htmlmixed=" data-lang="htmlmixed=">&lt;input _ngcontent-rgy-c18=&quot;&quot; accept=&quot;.pdf,.zip&quot; aria-label=&quot;Input area for 
uploading a single invoice PDF or XML B2B order file or a ZIP archive 
containing multiple invoices or orders&lt;!----&gt;&quot; id=&quot;file&quot; ng2fileselect=&quot;&quot; 
style=&quot;margin-left: 10px;&quot; type=&quot;file&quot;&gt;
</code></pre><p>However, in the actual JavaScript code, XML files can also be uploaded:</p><pre><code class="language-javascript=" data-lang="javascript=">public uploader: FileUploader = new FileUploader({
    url: environment.hostServer + '/file-upload',
    authToken: `Bearer ${localStorage.getItem('token')}`,
    allowedMimeType: [ 'application/pdf' , 'application/xml', 'text/xml' , 
    'application/zip', 'application/x-zip-compressed', 'multipart/x-zip'],
    maxFileSize: 100000
})
</code></pre><p>In Juice Shop, there is also an obvious configuration error in that error messages are not filtered. This results in relevant stack traces being returned to the client whenever the backend service encounters an error. Additionally, certain directories, such as FTP, should be configured to prevent users from directly listing the files in the directory.</p><h2 id=a7-cross-site-scripting-xss>A7: Cross-Site Scripting (XSS)</h2><p>Example: Stored XSS Attack</p><p>In the &ldquo;/api/feedbacks&rdquo; API, the &ldquo;comment&rdquo; parameter is not properly validated and filtered. The vulnerable code is as follows:</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports = (sequelize, { STRING, INTEGER }) =&gt; {
  const Feedback = sequelize.define('Feedback', {
    comment: {
      type: STRING,
      set (comment) {
        // Although there is a filtering operation here, the &quot;sanitize-html&quot;: &quot;1.4.2&quot; lib used has
        // vulnerabilities and cannot filter nested scripts
        const sanitizedComment = insecurity.sanitizeHtml(comment)
        this.setDataValue('comment', sanitizedComment)
      }
    },
  })

  Feedback.associate = ({ User }) =&gt; {
    Feedback.belongsTo(User) // no FK constraint to allow anonymous feedback posts
  }

  return Feedback
}
</code></pre><p>This vulnerability can be triggered using the following payload: <code>&lt;&lt;script>Foo&lt;/script>iframe src="javascript:alert(xss)"></code>.</p><h2 id=a8-unsafe-deserialization-vulnerability>A8: Unsafe Deserialization Vulnerability</h2><p>When dealing with complex POST requests, such as when an array is passed as a parameter from the frontend, the backend is required to perform deserialization to convert the client&rsquo;s string into an array in memory. However, if deserialization is done carelessly, it can lead to vulnerabilities that enable remote code execution.</p><p>In Juice Shop, the following code generates a deserialization vulnerability:</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports = function b2bOrder () {
  return ({ body }, res, next) =&gt; {
    if (!utils.disableOnContainerEnv()) {
      const orderLinesData = body.orderLinesData || ''
      try {
        const sandbox = { safeEval, orderLinesData }
        vm.createContext(sandbox)
        // safeEval directly runs the code, leading to vulnerabilities
        vm.runInContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })
        res.json({ cid: body.cid, orderNo: uniqueOrderNumber(), paymentDue: dateTwoWeeksFromNow() })
      } catch (err) {
        if (err.message &amp;&amp; err.message.match(/Script execution timed out.*/)) {
          res.status(503)
          next(new Error('Sorry, we are temporarily not available! Please try again later.'))
        } else {
          next(err)
        }
      }
    } else {
      res.json({ cid: body.cid, orderNo: uniqueOrderNumber(), paymentDue: dateTwoWeeksFromNow() })
    }
  }
}
</code></pre><p>It can be triggered with {&ldquo;orderLinesData&rdquo;: &ldquo;(function dos() { while(true); })()"}.</p><h2 id=a9-using-components-with-known-vulnerabilities>A9: Using Components with Known Vulnerabilities</h2><p>Juiceshop uses several components that have vulnerabilities, and some of them are even &ldquo;malicious&rdquo; components.</p><p>Here we mainly introduce the component express-jwt. The version of this component used in juiceshop has a vulnerability in forging tokens. In simple terms, the parameter &ldquo;algorithm&rdquo; is not verified in jws.verify, which allows attackers to change the algorithm to forge tokens.</p><p>However, upon closer inspection, the code of express-jwt is actually fine, and it is its dependent component jsonwebtoken that has problems. And jsonwebtoken is not directly the cause of the vulnerability, but its dependent component jws is the issue. The specific code that causes the vulnerability is as follows:</p><pre><code class="language-javascript=" data-lang="javascript=">function jwsVerify(jwsSig, secretOrKey) {
  jwsSig = toString(jwsSig);
  const signature = signatureFromJWS(jwsSig);
  const securedInput = securedInputFromJWS(jwsSig);
  // The algo parameter is not verified, allowing hackers to modify it.
  const algo = jwa(algoFromJWS(jwsSig));
  return algo.verify(securedInput, signature, secretOrKey);
}
</code></pre><p>For a more detailed and complete fix commit, please see<a href=https://github.com/brianloveswords/node-jws/commit/585d0e1e97b6747c10cf5b7689ccc5618a89b299>here</a>ã€‚</p><h2 id=a10-insufficient-logging-and-monitoring-of-vulnerabilities>A10: Insufficient Logging and Monitoring of Vulnerabilities</h2><p>There is no error logging and vulnerability monitoring in the entire web app.</p></div><div class=pagination><a href=/posts/systemcall/ class="left arrow">&#8592;</a>
<a href=/posts/owasp/ class="right arrow">&#8594;</a>
<a href=# class=top>Top</a></div></main><footer><span>&copy; <time datetime="2023-10-16 03:57:50.255966816 +0000 UTC m=+0.047912608">2023</time> Alex. Made with <a href=https://gohugo.io>Hugo</a> using the <a href=https://github.com/EmielH/tale-hugo/>Tale</a> theme.</span></footer></body></html>